import { Schema } from "@koda-rpc/parser";
import * as ts from 'typescript';
import { match } from 'ts-pattern';

const typeToKeyword = (type: string) => match(type)
  .with('number', () => ts.factory.createKeywordTypeNode(
    ts.SyntaxKind.NumberKeyword,
  ))
  .with('string', () => ts.factory.createKeywordTypeNode(
    ts.SyntaxKind.StringKeyword,
  ))
  .with('boolean', () => ts.factory.createKeywordTypeNode(
    ts.SyntaxKind.BooleanKeyword,
  ))
  .otherwise(() => ts.factory.createTypeReferenceNode(
    withInterfacePrefix(type),
    [],
  ));

const withInterfacePrefix = (name: string, postfix: string = ''): string => `I${name}${postfix}`;

export const codegen = (schema: Schema, fileName: string = ''): string => {
  const tsInterfaces = [];

  for (const contract of schema.contracts) {
    const members = contract.fields.map(field => {
      return ts.factory.createPropertySignature(
        [],
        field.name,
        undefined,
        typeToKeyword(field.type),
      );
    });

    tsInterfaces.push(
      ts.factory.createInterfaceDeclaration(
        [
          ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)
        ],
        withInterfacePrefix(contract.name),
        undefined,
        [],
        members,
      ),
    );
  }

  for (const service of schema.services) {
    const serviceMembers = service.methods.map(method => {
      const methodMembers = method.parameters.map(param => {
        return ts.factory.createParameterDeclaration(
          undefined,
          undefined,
          param.name,
          undefined,
          typeToKeyword(param.type),
        );
      });

      return ts.factory.createMethodDeclaration(
        [],
        undefined,
        method.name,
        undefined,
        undefined,
        methodMembers,
        typeToKeyword(method.returnType),
        undefined,
      );
    });

    tsInterfaces.push(
      ts.factory.createInterfaceDeclaration(
        [
          ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)
        ],
        withInterfacePrefix(service.name),
        undefined,
        [],
        // @ts-ignore
        serviceMembers,
      )
    )
  }

  let result = [
    '/* DO NOT MODIFY, AUTOGENERATED */',
    `/* GENERATED BY KODARPC CLI AT ${new Date().toString().toUpperCase()} */`
  ];

  const sourceFile = ts.createSourceFile(fileName, '', ts.ScriptTarget.ESNext);
  const printer = ts.createPrinter();

  tsInterfaces.forEach(interfaceNode => {
    const interfaceCode = printer.printNode(ts.EmitHint.Unspecified, interfaceNode, sourceFile);
    result.push(interfaceCode);
  });

  return result.join('\n');
};
